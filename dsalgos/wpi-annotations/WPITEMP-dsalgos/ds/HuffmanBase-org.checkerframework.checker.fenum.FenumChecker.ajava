package ds;

import java.io.File;
import java.io.IOException;
import java.nio.file.Files;
import java.util.PriorityQueue;

/*
 * Compress or expand a binary input stream using the Huffman algorithm.
 *
 * <p>****************************************************************************
 * </p>
 */
/**
 * The {@code HuffmanBase} class provides methods for a binary input using Huffman codes over the
 * 8-bit extended ASCII alphabet.
 *
 * <p>For additional documentation, see <a
 * href="https://algs4.cs.princeton.edu/55compression">Section 5.5</a> of <i>Algorithms, 4th
 * Edition</i> by Robert Sedgewick and Kevin Wayne.
 *
 * @author Robert Sedgewick
 * @author Kevin Wayne
 */
@org.checkerframework.framework.qual.AnnotatedFor("org.checkerframework.checker.fenum.FenumChecker")
public abstract class HuffmanBase {

    // alphabet size of extended ASCII
    static final  @org.checkerframework.checker.fenum.qual.FenumUnqualified int R = 256;

    static final  @org.checkerframework.checker.fenum.qual.FenumUnqualified char NULL_CHARACTER = '\0';

    static final  @org.checkerframework.checker.fenum.qual.FenumUnqualified char ZERO_CHARACTER = '0';

    static final  @org.checkerframework.checker.fenum.qual.FenumUnqualified char ONE_CHARACTER = '1';

    protected final @org.checkerframework.checker.fenum.qual.FenumUnqualified BinaryInputStream bis;

    protected final @org.checkerframework.checker.fenum.qual.FenumUnqualified BinaryOutputStream bos;

    public HuffmanBase(@org.checkerframework.checker.fenum.qual.FenumUnqualified File input, @org.checkerframework.checker.fenum.qual.FenumUnqualified File output) throws IOException {
        this.bis = new BinaryInputStream(Files.newInputStream(input.toPath()));
        this.bos = new BinaryOutputStream(Files.newOutputStream(output.toPath()));
    }

    // build the Huffman trie given frequencies
    protected @org.checkerframework.checker.fenum.qual.FenumUnqualified Node buildTrie(@org.checkerframework.checker.fenum.qual.FenumUnqualified HuffmanBase this,  @org.checkerframework.checker.fenum.qual.FenumUnqualified int@org.checkerframework.checker.fenum.qual.FenumUnqualified ... freq) {
        // initialize priority queue with singleton trees
        PriorityQueue<Node> pq = new PriorityQueue<>();
        Node node = new Node('a', 0, null, null);
        for (char c = 0; c < R; c++) if (freq[c] > 0) {
            Node newNode = node.clone();
            newNode.ch = c;
            newNode.freq = freq[c];
            pq.offer(newNode);
        }
        // merge two smallest trees
        while (pq.size() > 1) {
            Node left = pq.poll();
            Node right = pq.poll();
            Node parent = node.clone();
            parent.left = left;
            parent.right = right;
            parent.ch = NULL_CHARACTER;
            parent.freq = left.freq + right.freq;
            pq.offer(parent);
        }
        return pq.poll();
    }

    // write bitstring-encoded trie to standard output
    protected void writeTrie(@org.checkerframework.checker.fenum.qual.FenumUnqualified HuffmanBase this, @org.checkerframework.checker.fenum.qual.FenumUnqualified Node x) {
        if (x.isLeaf()) {
            bos.write(true);
            bos.write(x.ch, 8);
            return;
        }
        bos.write(false);
        writeTrie(x.left);
        writeTrie(x.right);
    }

    // make a lookup table from symbols and their encodings
    protected void buildCode(@org.checkerframework.checker.fenum.qual.FenumUnqualified HuffmanBase this, @org.checkerframework.checker.fenum.qual.FenumUnqualified String @org.checkerframework.checker.fenum.qual.FenumUnqualified [] st, @org.checkerframework.checker.fenum.qual.FenumUnqualified Node x, @org.checkerframework.checker.fenum.qual.FenumUnqualified String s) {
        if (x.isLeaf())
            st[x.ch] = s;
        else {
            buildCode(st, x.left, s + '0');
            buildCode(st, x.right, s + '1');
        }
    }

    protected @org.checkerframework.checker.fenum.qual.FenumUnqualified Node readTrie(@org.checkerframework.checker.fenum.qual.FenumUnqualified HuffmanBase this) {
        boolean isLeaf = bis.readBoolean();
        if (isLeaf) {
            char ch = bis.readChar();
            return new Node(ch, -1, null, null);
        } else
            return new Node(NULL_CHARACTER, -1, readTrie(), readTrie());
    }

    // Huffman trie node
    protected static final class Node implements Cloneable, Comparable<Node> {

         @org.checkerframework.checker.fenum.qual.FenumUnqualified char ch;

         @org.checkerframework.checker.fenum.qual.FenumUnqualified int freq;

        @org.checkerframework.checker.fenum.qual.FenumUnqualified Node left;

        @org.checkerframework.checker.fenum.qual.FenumUnqualified Node right;

        Node( @org.checkerframework.checker.fenum.qual.FenumUnqualified char ch,  @org.checkerframework.checker.fenum.qual.FenumUnqualified int freq, @org.checkerframework.checker.fenum.qual.FenumUnqualified Node left, @org.checkerframework.checker.fenum.qual.FenumUnqualified Node right) {
            this.ch = ch;
            this.freq = freq;
            this.left = left;
            this.right = right;
        }

        // is the node a leaf node?
        @org.checkerframework.dataflow.qual.Pure
         @org.checkerframework.checker.fenum.qual.FenumUnqualified boolean isLeaf(@org.checkerframework.checker.fenum.qual.FenumUnqualified Node this) {
            return left == null && right == null;
        }

        // compare, based on frequency
        @org.checkerframework.dataflow.qual.Pure
        public  @org.checkerframework.checker.fenum.qual.FenumUnqualified int compareTo(@org.checkerframework.checker.fenum.qual.FenumUnqualified Node this, @org.checkerframework.checker.fenum.qual.FenumUnqualified Node that) {
            return this.freq - that.freq;
        }

        @org.checkerframework.dataflow.qual.SideEffectFree
        public @org.checkerframework.checker.fenum.qual.FenumUnqualified Node clone(@org.checkerframework.checker.fenum.qual.FenumUnqualified Node this) {
            try {
                return (Node) super.clone();
            } catch (CloneNotSupportedException cnse) {
                throw new AssertionError("Shouldn't get here..." + cnse.getMessage(), cnse);
            }
        }
    }
}
