package ds.knapsack;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

@org.checkerframework.framework.qual.AnnotatedFor("org.checkerframework.checker.optional.OptionalChecker")
public class NaiveKnapsack extends AbstractKnapsack<Solution<Integer>> {

    public NaiveKnapsack(@org.checkerframework.checker.optional.qual.MaybePresent Item @org.checkerframework.checker.optional.qual.MaybePresent [] items,  @org.checkerframework.checker.optional.qual.MaybePresent int capacity) {
        super(items, capacity);
    }

    private void put(@org.checkerframework.checker.optional.qual.MaybePresent NaiveKnapsack this, @org.checkerframework.checker.optional.qual.MaybePresent Map<WeightCountTuple, Integer> vals, @org.checkerframework.checker.optional.qual.MaybePresent WeightCountTuple wct, @org.checkerframework.checker.optional.qual.MaybePresent Integer val) {
        vals.put(wct, val);
    }

    @org.checkerframework.dataflow.qual.Pure
    private  @org.checkerframework.checker.optional.qual.MaybePresent boolean containsKey(@org.checkerframework.checker.optional.qual.MaybePresent NaiveKnapsack this, @org.checkerframework.checker.optional.qual.MaybePresent Map<WeightCountTuple, Integer> vals, @org.checkerframework.checker.optional.qual.MaybePresent WeightCountTuple wct) {
        return vals.containsKey(wct);
    }

    @org.checkerframework.dataflow.qual.Pure
    private Integer get(Map<WeightCountTuple, Integer> vals, WeightCountTuple wct) {
        return vals.get(wct);
    }

    public @org.checkerframework.checker.optional.qual.MaybePresent Solution<Integer> solve(@org.checkerframework.checker.optional.qual.MaybePresent NaiveKnapsack this) {
        List<Item> itemsSolution = new ArrayList<>(0);
        Map<WeightCountTuple, Integer> vals = new HashMap<>();
        int maximalValue = knapsack(capacity, items.length, itemsSolution, vals);
        return new Solution<>(itemsSolution, maximalValue);
    }

    private  @org.checkerframework.checker.optional.qual.MaybePresent int knapsack(@org.checkerframework.checker.optional.qual.MaybePresent NaiveKnapsack this,  @org.checkerframework.checker.optional.qual.MaybePresent int totalWeight,  @org.checkerframework.checker.optional.qual.MaybePresent int n, @org.checkerframework.checker.optional.qual.MaybePresent List<Item> solutionItems, @org.checkerframework.checker.optional.qual.MaybePresent Map<WeightCountTuple, Integer> vals) {
        if (n == 0 || totalWeight == 0)
            return 0;
        WeightCountTuple wct = new WeightCountTuple(totalWeight, n - 1);
        if (containsKey(vals, wct))
            return get(vals, wct);
        /**
         * If weight of nth item is more than capacity W, then this item cannot be included in the
         * optimal solution.
         */
        if (items[n - 1].weight > totalWeight) {
            //    solutionItems.remove(items[n - 1]);
            int val = knapsack(totalWeight, n - 1, solutionItems, vals);
            put(vals, wct, val);
            return val;
        }
        /**
         * Return the maximum of two cases: (1) nth item included (2) not included *
         */
        int notIncludedVal = knapsack(totalWeight, n - 1, solutionItems, vals);
        int newWeight = totalWeight - items[n - 1].weight;
        int remainder = knapsack(newWeight, n - 1, solutionItems, vals);
        int includedVal = items[n - 1].value + remainder;
        boolean included = includedVal > notIncludedVal;
        if (included) {
            if (!solutionItems.contains(items[n - 1])) {
                solutionItems.add(items[n - 1]);
            }
            put(vals, wct, includedVal);
            return includedVal;
        } else {
            solutionItems.remove(items[n - 1]);
            put(vals, wct, notIncludedVal);
            return notIncludedVal;
        }
    }
}
