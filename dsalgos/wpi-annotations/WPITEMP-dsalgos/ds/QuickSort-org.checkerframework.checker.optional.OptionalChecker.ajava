package ds;

import static ds.RandomUtils.randomInRange;

/**
 * Quick sort using random partitioning.
 */
@org.checkerframework.framework.qual.AnnotatedFor("org.checkerframework.checker.optional.OptionalChecker")
public class QuickSort extends AbstractSort {

    protected void sort(@org.checkerframework.checker.optional.qual.MaybePresent QuickSort this,  @org.checkerframework.checker.optional.qual.MaybePresent long @org.checkerframework.checker.optional.qual.MaybePresent [] a,  @org.checkerframework.checker.optional.qual.MaybePresent int length) {
        if (!shouldSort(length))
            return;
        quickSort(a, 0, length - 1);
    }

    private  @org.checkerframework.checker.optional.qual.MaybePresent int randomPartition(@org.checkerframework.checker.optional.qual.MaybePresent QuickSort this,  @org.checkerframework.checker.optional.qual.MaybePresent long @org.checkerframework.checker.optional.qual.MaybePresent [] a,  @org.checkerframework.checker.optional.qual.MaybePresent int low,  @org.checkerframework.checker.optional.qual.MaybePresent int high) {
        int random = randomInRange(low, high + 1);
        if (random != high && a[random] > a[high]) {
            swap(a, random, high);
            ++swapCount;
        }
        if (random != high)
            ++comparisonCount;
        return partition(a, low, high);
    }

    /*
   * This function takes last element as pivot, places
  the pivot element at its correct position in sorted
  array, and places all smaller (smaller than pivot)
  to left of pivot and all greater elements to right
  of pivot
  */
     @org.checkerframework.checker.optional.qual.MaybePresent int partition(@org.checkerframework.checker.optional.qual.MaybePresent QuickSort this,  @org.checkerframework.checker.optional.qual.MaybePresent long @org.checkerframework.checker.optional.qual.MaybePresent [] a,  @org.checkerframework.checker.optional.qual.MaybePresent int low,  @org.checkerframework.checker.optional.qual.MaybePresent int high) {
        long pivot = a[high];
        int i = low - 1;
        // Index of smaller element
        for (int j = low; j < high; ++j) {
            // If current element is smaller than or
            // equal to pivot
            ++innerLoopCount;
            ++comparisonCount;
            if (a[j] <= pivot) {
                ++i;
                if (i != j) {
                    swap(a, i, j);
                    ++swapCount;
                }
            }
        }
        ++i;
        if (i != high) {
            swap(a, i, high);
            ++swapCount;
        }
        return i;
    }

    /*
   * This QuickSort requires O(Log n) auxiliary space in worst case.
   */
    void quickSort(@org.checkerframework.checker.optional.qual.MaybePresent QuickSort this,  @org.checkerframework.checker.optional.qual.MaybePresent long @org.checkerframework.checker.optional.qual.MaybePresent [] a,  @org.checkerframework.checker.optional.qual.MaybePresent int lower,  @org.checkerframework.checker.optional.qual.MaybePresent int upper) {
        int low = lower;
        int high = upper;
        while (low < high) {
            ++outerLoopCount;
            /* pi is partitioning index, a[p] is now
      at right place */
            int pi = randomPartition(a, low, high);
            // If left part is smaller, then recur for left
            // part and handle right part iteratively
            if (pi - low < high - pi) {
                quickSort(a, low, pi - 1);
                low = pi + 1;
            } else {
                quickSort(a, pi + 1, high);
                high = pi - 1;
            }
        }
    }
}
