package ds;

import static java.util.Objects.isNull;
import static java.util.Objects.nonNull;
import static java.util.Objects.requireNonNull;
import java.util.Objects;

@org.checkerframework.framework.qual.AnnotatedFor("org.checkerframework.checker.nullness.KeyForSubchecker")
public class TreeNode<T extends Comparable<T>> implements ITreeNode<T> {

    /**
     * Data object reference.
     */
    T val;

    /**
     * Left and right child nodes.
     */
     ITreeNode<T> left;

     ITreeNode<T> right;

    // height of the subtree
      int height;

    // number of nodes in subtree
      int size;

    // number of copies in node
      int refCount;

    // priority
    int priority;

    /**
     * Constructor for TreeNode.
     *
     * @param val data object reference
     * @param left left child node reference or null
     * @param right right child node reference or null
     */
    TreeNode(T val, TreeNode<T> left, TreeNode<T> right) {
        this.val = val;
        this.left = left;
        this.right = right;
        this.refCount = 1;
    }

    TreeNode(T val) {
        this(val, null, null);
        this.size = 1;
        this.height = 0;
    }

    public void incrementRefCount( TreeNode<T> this) {
        ++refCount;
        ++size;
    }

    public void decrementRefCount( TreeNode<T> this) {
        --refCount;
        --size;
    }

    @org.checkerframework.dataflow.qual.Pure
    public   int refCount( TreeNode<T> this) {
        return refCount;
    }

    @org.checkerframework.dataflow.qual.Pure
    public   int height( TreeNode<T> this) {
        return this.height;
    }

    @org.checkerframework.dataflow.qual.Pure
    private   int height( TreeNode<T> this,  ITreeNode<T> x) {
        return isNull(x) ? -1 : x.height();
    }

    @org.checkerframework.dataflow.qual.Pure
    public   int size( TreeNode<T> this) {
        return this.size;
    }

    public void setSize( TreeNode<T> this,   int size) {
        this.size = size;
    }

    public void setHeight( TreeNode<T> this,   int ht) {
        this.height = ht;
    }

    @org.checkerframework.dataflow.qual.Pure
    public   int balanceFactor( TreeNode<T> this) {
        return height(left()) - height(right());
    }

    @org.checkerframework.dataflow.qual.Pure
    public  ITreeNode<T> left( TreeNode<T> this) {
        return left;
    }

    @org.checkerframework.dataflow.qual.Pure
    public  ITreeNode<T> right( TreeNode<T> this) {
        return right;
    }

    public void setRight( TreeNode<T> this,  ITreeNode<T> right) {
        this.right = right;
    }

    public void setLeft( TreeNode<T> this,  ITreeNode<T> left) {
        this.left = left;
    }

    public void setValue( TreeNode<T> this, T val) {
        this.val = val;
    }

    @org.checkerframework.dataflow.qual.Pure
    public T value( TreeNode<T> this) {
        return val;
    }

    /**
     * Insert an object into the tree.
     *
     * @param obj object to insert into tree.
     */
    public void insert( TreeNode<T> this, T obj) {
        requireNonNull(obj);
        if (val.compareTo(obj) < 0) {
            if (isNull(right))
                right = new TreeNode<>(obj, null, null);
            else
                right.insert(obj);
        } else {
            if (isNull(left))
                left = new TreeNode<>(obj, null, null);
            else
                left.insert(obj);
        }
    }

    /**
     * Find an object in the tree. Objects are compared using the compareTo method, so must conform to
     * type Comparable. Two objects are equal if they represent the same value.
     *
     * @param obj Object representing value to find in tree.
     * @return reference to matching node or null.
     */
    @org.checkerframework.dataflow.qual.Pure
    public  ITreeNode<T> find( TreeNode<T> this, T obj) {
        int temp = val.compareTo(obj);
        if (temp == 0)
            return this;
        if (temp < 0)
            return isNull(right) ? null : right.find(obj);
        return isNull(left) ? null : left.find(obj);
    }

    /**
     * Remove the node referencing an object representing the same value as the argument object. This
     * recursive method essentially restructures the tree as necessary and returns a reference to the
     * new root. The algorithm is straightforward apart from the case where the node to be removed has
     * two children. In that case the left-most leaf node of the right child is moved up the tree to
     * replace the removed node. Hand work some examples to see how this works.
     *
     * @param obj Object representing value to remove from tree.
     * @return reference to the (possibly new) root node of the sub-tree being examined or null if no
     *     node.
     */
    public  ITreeNode<T> remove( TreeNode<T> this, T obj) {
        requireNonNull(obj);
        ITreeNode<T> t = this;
        ITreeNode<T> left = t.left();
        ITreeNode<T> right = t.right();
        T value = t.value();
        int cmp = obj.compareTo(value);
        if (cmp == 0) {
            if (isNull(left) || isNull(right))
                t = isNull(left) ? right : left;
            else {
                t.setValue(findMin(right).value());
                t.setRight(right.remove(t.value()));
            }
        } else if (cmp < 0)
            t.setLeft(left.remove(obj));
        else
            t.setRight(right.remove(obj));
        return t;
    }

    /**
     * Helper method to find the left most leaf node in a sub-tree.
     *
     * @param t TreeNode to be examined.
     * @return reference to left most leaf node or null.
     */
    @org.checkerframework.dataflow.qual.Pure
    private  ITreeNode<T> findMin( TreeNode<T> this,  ITreeNode<T> node) {
        ITreeNode<T> t = node;
        while (nonNull(t.left())) t = t.left();
        return t;
    }

    @org.checkerframework.dataflow.qual.SideEffectFree
    public  String toString( TreeNode<T> this) {
        return Objects.toString(val);
    }

    @org.checkerframework.dataflow.qual.SideEffectFree
    public  ITreeNode<T> clone( TreeNode<T> this) {
        try {
            return (ITreeNode<T>) super.clone();
        } catch (CloneNotSupportedException cnse) {
            throw new AssertionError("Shouldn't reach here...", cnse);
        }
    }
}
